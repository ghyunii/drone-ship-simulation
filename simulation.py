# -*- coding: utf-8 -*-
"""simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16mLSvgNs75vMHOcbVzH6o3xCJaib0-x5
"""

import random
import math
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import matplotlib.image as mpimg
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

mpl.rcParams['animation.embed_limit'] = 50 * 1024 * 1024  # 50MB

class IllegalShip:
    def __init__(self, id, x, y, speed_kmph=13.0, health=500, boundary=8.8):
        self.id = id
        self.x = x
        self.y = y
        self.speed_kmph = speed_kmph
        self.speed = None
        self.health = health
        self.alive = True
        self.detected = False
        self.escape_mode = False
        self.direction = random.uniform(0, 2 * math.pi)
        self.direction_change_counter = 0
        self.path = []
        self.boundary = boundary

    def update_speed(self, dt_sec):
        self.speed = self.speed_kmph / 3600 * dt_sec

    def fish(self):
        self.direction_change_counter += 1
        # 방향 변경 빈도 감소 - 더 자연스러운 움직임을 위해
        if self.direction_change_counter >= 50:  # 30에서 50으로 증가
            self.direction = random.uniform(0, 2 * math.pi)
            self.direction_change_counter = 0
        self.x += self.speed * math.cos(self.direction)
        self.y += self.speed * math.sin(self.direction)
        self.x = max(-self.boundary, min(self.boundary, self.x))
        self.y = max(-self.boundary, min(self.boundary, self.y))
        self.path.append((self.x, self.y))
        if len(self.path) > 50:
            self.path.pop(0)

    def flee(self):
        if not hasattr(self, 'escape_counter'):
            self.escape_counter = 0
            self.escape_phase = 0
            self.escape_direction = math.pi/2 + random.uniform(-0.4, 0.4)
        self.escape_counter += 1
        if self.escape_counter > random.randint(15, 20):
            self.escape_counter = 0
            self.escape_phase = (self.escape_phase + 1) % 4
            base_direction = math.pi/2
            self.escape_direction = base_direction + random.uniform(-0.7, 0.7)
        zigzag = 0.2 * math.sin(self.escape_counter * 0.3 + self.escape_phase)
        escape_angle = self.escape_direction + zigzag
        speed_variation = random.uniform(0.9, 1.1)
        escape_speed = self.speed * 1.8 * speed_variation
        self.x += escape_speed * math.cos(escape_angle)
        self.y += escape_speed * math.sin(escape_angle)
        self.x = max(-self.boundary, min(self.boundary, self.x))
        self.y = max(-self.boundary, min(self.boundary, self.y))

    def update(self, frame, detect_frame_threshold=300):
        if not self.alive:
            return
        if not self.detected:
            self.fish()
        elif self.health > 0:
            self.escape_mode = True
            self.flee()
        else:
            # 기동불능 상태에서는 이동하지 않음
            pass

    def get_status(self):
        if not self.alive or self.health <= 0:
            return "disabled"
        elif self.detected:
            return "detected"  # "attacked"에서 "detected"로 변경
        else:
            return "fishing"

class Drone:
    def __init__(self, id, x, y, speed_kmph=120.0, detection_range=1.2,
                 attack_power=10, boundary=8.8):
        self.id = id
        self.x = x
        self.y = y
        self.base = np.array((0.0, 0.0))
        self.speed_kmph = speed_kmph
        self.speed = None
        self.detection_range = detection_range
        self.attack_power = attack_power
        self.state = 'patrol'
        self.target_ship = None
        self.surround_point = None
        self.boundary = boundary
        # 사분면 기반 패트롤 범위 설정
        self.patrol_quadrant = id % 4  # 0=1사분면, 1=2사분면, 2=3사분면, 3=4사분면
        self.set_patrol_parameters()
        self.support_requested = False
        self.path = []
        self.force_surround = False
        self.scan_angle = random.uniform(0, 2 * math.pi)  # 탐지 패턴을 위한 스캔 각도
        self.scan_direction = 1  # 스캔 방향 (1: 시계 방향, -1: 반시계 방향)

    def set_patrol_parameters(self):
        # 사분면에 따른 순찰 파라미터 설정
        quadrant_centers = [
            (self.boundary * 0.5, self.boundary * 0.5),    # 제1사분면
            (-self.boundary * 0.5, self.boundary * 0.5),   # 제2사분면
            (-self.boundary * 0.5, -self.boundary * 0.5),  # 제3사분면
            (self.boundary * 0.5, -self.boundary * 0.5)    # 제4사분면
        ]
        angle_ranges = [
            (0, math.pi/2),             # 제1사분면
            (math.pi/2, math.pi),       # 제2사분면
            (math.pi, 3*math.pi/2),     # 제3사분면
            (3*math.pi/2, 2*math.pi)    # 제4사분면
        ]

        self.patrol_center_x, self.patrol_center_y = quadrant_centers[self.patrol_quadrant]
        angle_min, angle_max = angle_ranges[self.patrol_quadrant]
        self.patrol_angle = random.uniform(angle_min, angle_max)
        self.patrol_radius = random.uniform(2.0, 4.0)

        # 패트롤 경로를 위한 초기화
        self.patrol_path = []
        self.current_patrol_point = 0
        self.generate_patrol_path()

    def generate_patrol_path(self):
        """사분면 내에서 순찰 경로를 생성합니다."""
        self.patrol_path = []
        num_points = 5  # 경로 포인트 수

        # 사분면 범위에 맞게 경로점 생성
        angle_min = self.patrol_quadrant * math.pi/2
        angle_max = (self.patrol_quadrant + 1) * math.pi/2

        for _ in range(num_points):
            radius = random.uniform(1.5, self.boundary * 0.7)
            angle = random.uniform(angle_min, angle_max)

            x = radius * math.cos(angle)
            y = radius * math.sin(angle)

            # 사분면에 따라 조정
            if self.patrol_quadrant == 0:  # 제1사분면
                x, y = abs(x), abs(y)
            elif self.patrol_quadrant == 1:  # 제2사분면
                x, y = -abs(x), abs(y)
            elif self.patrol_quadrant == 2:  # 제3사분면
                x, y = -abs(x), -abs(y)
            else:  # 제4사분면
                x, y = abs(x), -abs(y)

            self.patrol_path.append((x, y))

    def update_speed(self, dt_sec):
        self.speed = self.speed_kmph / 3600 * dt_sec

    def set_target(self, ship):
        self.target_ship = ship
        self.state = 'pursuit'
        return True

    def update_surround_point(self, pt):
        self.surround_point = np.array(pt, dtype=float)

    def _move_towards(self, tx, ty):
        dx, dy = tx - self.x, ty - self.y
        dist = math.hypot(dx, dy)
        if dist == 0:
            return 0
        step = min(self.speed, dist)
        self.x += step * dx / dist
        self.y += step * dy / dist
        return dist

    def _patrol_move(self):
        # 패트롤 경로를 따라 이동
        if not self.patrol_path:
            self.generate_patrol_path()
            self.current_patrol_point = 0

        # 현재 목표 지점
        target_x, target_y = self.patrol_path[self.current_patrol_point]

        # 스캔 동작 구현 (탐지 패턴)
        self.scan_angle += self.scan_direction * 0.03
        # 스캔 방향 가끔 바꾸기
        if random.random() < 0.005:
            self.scan_direction *= -1

        # 기본 이동 방향에 스캔 패턴 추가
        dx = target_x - self.x
        dy = target_y - self.y
        dist = math.hypot(dx, dy)

        # 목표 지점에 도달하면 다음 지점으로
        if dist < self.speed:
            self.current_patrol_point = (self.current_patrol_point + 1) % len(self.patrol_path)
            # 가끔 새 경로 생성
            if random.random() < 0.2:
                self.generate_patrol_path()

        # 패트롤 속도 (정찰 모드에서는 더 느리게)
        patrol_speed = self.speed * 0.5

        if dist > 0:
            self.x += patrol_speed * dx / dist
            self.y += patrol_speed * dy / dist

            # 경계 확인
            self.x = max(-self.boundary, min(self.boundary, self.x))
            self.y = max(-self.boundary, min(self.boundary, self.y))

    def _pursue_target(self):
        if not self.target_ship:
            self.state = 'patrol'
            self.target_ship = None
            return False
        if not self.target_ship.alive:
            self.state = 'surrounding'
            return True
        tx = max(-self.boundary, min(self.boundary, self.target_ship.x))
        ty = max(-self.boundary, min(self.boundary, self.target_ship.y))
        dist = self._move_towards(tx, ty)
        # 공격: 일정 거리 이내면 공격하고 공격력 증가
        if dist < 0.8:
            # 더 효과적인 공격을 위한 공격력 증가
            attack_multiplier = 1.0 + (1.0 - dist/0.8) * 0.5  # 거리가 가까울수록 공격력 증가
            current_attack = self.attack_power * attack_multiplier
            self.target_ship.health -= current_attack
            if self.target_ship.health <= 0:
                self.target_ship.health = 0
                self.target_ship.alive = False
                self.state = 'surrounding'

        # 어느 정도 접근하면 포위 상태로 전환
        if dist <= self.detection_range * 1.5 and self.target_ship.health > 0:
            self.state = 'surrounding'
        return True

    def _surround_target(self):
        """포위 상태에서의 행동"""
        if not self.target_ship:
            self.state = 'patrol'
            return False

        # 각 드론이 불법어선을 중심으로 고르게 배치되도록 함
        angle = 2 * math.pi * (self.id % 4) / 4
        surround_dist = 1.0  # 더 가까운 거리로 포위

        # 조금씩 주변을 회전하며 포위
        angle += 0.005 * (1 if self.id % 2 == 0 else -1)  # 짝수/홀수 드론이 반대 방향으로 회전

        guard_x = self.target_ship.x + surround_dist * math.cos(angle)
        guard_y = self.target_ship.y + surround_dist * math.sin(angle)
        guard_x = max(-self.boundary, min(self.boundary, guard_x))
        guard_y = max(-self.boundary, min(self.boundary, guard_y))

        dist = self._move_towards(guard_x, guard_y)

        # 포위하면서도 계속 공격
        if dist < 0.8 and self.target_ship.health > 0:
            attack_power = self.attack_power * 1.2  # 포위 상태에서 공격력 증가
            self.target_ship.health -= attack_power
            if self.target_ship.health <= 0:
                self.target_ship.health = 0
                self.target_ship.alive = False
                self.state = 'guarding'

        return True

    def move(self, frame):
        # 경계 확인
        if abs(self.x) > self.boundary or abs(self.y) > self.boundary:
            angle_to_center = math.atan2(-self.y, -self.x)
            self.x = max(-self.boundary, min(self.boundary, self.x))
            self.y = max(-self.boundary, min(self.boundary, self.y))
            if self.state == 'patrol':
                self.patrol_angle = angle_to_center + random.uniform(-0.5, 0.5)

        # 상태에 따른 행동
        if self.state == 'patrol':
            self._patrol_move()
            return False
        elif self.state == 'pursuit':
            return self._pursue_target()
        elif self.state == 'surrounding':
            return self._surround_target()
        elif self.state == 'guarding':
            if self.target_ship:
                if hasattr(self, 'guard_angle'):
                    self.guard_angle += 0.02
                else:
                    self.guard_angle = 2 * math.pi * (self.id % 4) / 4
                guard_distance = 0.8  # 더 가까운 거리로 포위
                guard_x = self.target_ship.x + guard_distance * math.cos(self.guard_angle)
                guard_y = self.target_ship.y + guard_distance * math.sin(self.guard_angle)
                guard_x = max(-self.boundary, min(self.boundary, guard_x))
                guard_y = max(-self.boundary, min(self.boundary, guard_y))
                self._move_towards(guard_x, guard_y)
            else:
                self.state = 'patrol'
        return False

    def detect_ships(self, ships, frame, detection_threshold=800):
        # 탐지 시점을 늦추기 위해 프레임 체크 추가
        if self.state != 'patrol' or frame < detection_threshold:
            return None
        for ship in ships:
            dist = math.hypot(self.x - ship.x, self.y - ship.y)
            if dist <= self.detection_range and not ship.detected and ship.alive:
                ship.detected = True
                return ship
        return None

class Simulation:
    def __init__(self, drones, ships, surround_dist=1.5,
                 total_time_sec=14400, xlim=(-8.8, 8.8), ylim=(-8.8, 8.8), frames=2400,
                 background_image_path=None):
        self.drones = drones
        self.ships = ships
        self.surround_dist = surround_dist
        self.frames = frames
        self.dt = total_time_sec / frames
        self.support_teams = {}
        self.detection_threshold = 800  # 탐지 시작 프레임 (늦게 탐지 시작)

        for ship in ships:
            ship.update_speed(self.dt)
        for d in drones:
            d.update_speed(self.dt)

        self.fig, self.ax = plt.subplots(figsize=(10, 8))
        self.ax.set_xlim(*xlim)
        self.ax.set_ylim(*ylim)
        self.ax.set_aspect('equal')

        # 연평도 배경 이미지 추가
        if background_image_path is not None:
            try:
                img = mpimg.imread(background_image_path)
                self.ax.imshow(img, extent=[xlim[0], xlim[1], ylim[0], ylim[1]], aspect='auto', zorder=-100)
            except Exception as e:
                print(f"배경 이미지를 로드할 수 없습니다: {e}")

        # 작전 구역 표시 (원)
        zone = plt.Circle((0, 0), max(abs(xlim[0]), abs(xlim[1])),
                          color='gray', fill=False, linestyle='--', alpha=0.5)
        self.ax.add_artist(zone)

        # 사분면 표시 (경계선)
        self.ax.axhline(y=0, color='gray', linestyle=':', alpha=0.5)
        self.ax.axvline(x=0, color='gray', linestyle=':', alpha=0.5)

        # 각 사분면에 레이블 추가
        quadrant_labels = ["제1사분면", "제2사분면", "제3사분면", "제4사분면"]
        quadrant_positions = [(5, 5), (-5, 5), (-5, -5), (5, -5)]
        for label, pos in zip(quadrant_labels, quadrant_positions):
            self.ax.text(pos[0], pos[1], label, fontsize=8, ha='center', va='center', alpha=0.7)

        # 드론 탐지반경: 빨간색 윤곽선 원
        self.detection_circles = [
            plt.Circle((0,0), d.detection_range, fill=False,
                       linestyle='-', edgecolor='red', linewidth=2, alpha=0.8, zorder=3)
            for d in drones
        ]
        for circ in self.detection_circles:
            self.ax.add_patch(circ)

        # 탐지 패턴 표시용 선
        self.scan_lines = [
            plt.Line2D([0, 0], [0, 0], color='yellow', linewidth=1, alpha=0.6, zorder=4)
            for _ in drones
        ]
        for line in self.scan_lines:
            self.ax.add_line(line)

        # 드론과 불법어선 스캐터 플롯
        self.dr_scatter = self.ax.scatter([], [], s=100, marker='^', label='Drone')
        self.sh_scatter = self.ax.scatter([], [], s=150, marker='s', c='green', label='Illegal Ship')

        # 패트롤 경로 표시 (옅은 점선)
        self.patrol_lines = []
        for i, drone in enumerate(drones):
            color = plt.cm.tab10(i % 10)
            line, = self.ax.plot([], [], 'o-', color=color, alpha=0.3, markersize=3, linewidth=1)
            self.patrol_lines.append(line)

        self.colors = {
            'patrol': 'blue',
            'pursuit': 'orange',
            'surrounding': 'cyan',
            'attacking': 'orange',
            'guarding': 'purple'
        }

        self.ship_status_colors = {
            "fishing": "green",
            "detected": "orange",  # "attacked"에서 "detected"로 변경
            "disabled": "gray"
        }

        # 상태 표시 범례 추가
        from matplotlib.lines import Line2D
        legend_elements = [
            Line2D([0], [0], marker='s', color='w', markerfacecolor='green', markersize=10, label='Fishing'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor='orange', markersize=10, label='Detected'),
            Line2D([0], [0], marker='s', color='w', markerfacecolor='gray', markersize=10, label='Disabled')
        ]

        # 드론 상태 범례 추가
        drone_legend_elements = [
            Line2D([0], [0], marker='^', color='w', markerfacecolor='blue', markersize=10, label='Patrol'),
            Line2D([0], [0], marker='^', color='w', markerfacecolor='orange', markersize=10, label='Pursuit'),
            Line2D([0], [0], marker='^', color='w', markerfacecolor='cyan', markersize=10, label='Surrounding'),
            Line2D([0], [0], marker='^', color='w', markerfacecolor='purple', markersize=10, label='Guarding')
        ]

        # 두 범례 합치기
        all_legend_elements = legend_elements + drone_legend_elements
        self.ax.legend(handles=all_legend_elements, loc='upper right', fontsize=8)

        self.status_text = self.ax.text(xlim[0] + 0.5, ylim[1] - 1.0, "", fontsize=10)
        self.time_text = self.ax.text(xlim[0] + 0.5, ylim[1] - 0.5, "", fontsize=10)

    def init(self):
        self.dr_scatter.set_offsets(np.empty((0, 2)))
        self.sh_scatter.set_offsets(np.empty((0, 2)))
        self.status_text.set_text("")
        self.time_text.set_text("")

        # 탐지 선 초기화
        for line in self.scan_lines:
            line.set_data([], [])

        # 패트롤 경로 초기화
        for line in self.patrol_lines:
            line.set_data([], [])

        return [self.dr_scatter, self.sh_scatter, self.status_text, self.time_text] + self.detection_circles + self.scan_lines + self.patrol_lines

    def central_control(self, ship, frame):
        points = []
        n = len(self.drones)
        if frame >= self.detection_threshold + 900:
            surround_dist = self.surround_dist * 0.8  # 더 촘촘하게 포위
        else:
            surround_dist = self.surround_dist
        for idx in range(n):
            angle = 2 * math.pi * idx / n + random.uniform(-0.1, 0.1)
            dist = surround_dist * (1 + random.uniform(-0.2, 0.2))
            x = ship.x + dist * math.cos(angle)
            y = ship.y + dist * math.sin(angle)
            x = max(-8.8, min(8.8, x))
            y = max(-8.8, min(8.8, y))
            points.append((x, y))
        return points

    def _assign_target_to_drones(self, ship, frame):
        for drone in self.drones:
            drone.set_target(ship)
            # 발견된 시점에 따라 공격력 조정
            if frame < self.detection_threshold + 300:
                drone.attack_power = 8  # 약간 감소
            elif frame < self.detection_threshold + 600:
                drone.attack_power = 12
            else:
                drone.attack_power = 16

    def update(self, frame):
        if frame < self.detection_threshold:
            phase = "Phase 1: Patrol and Observation"
        elif self.detection_threshold <= frame < self.detection_threshold + 600:
            phase = "Phase 2: Pursuit and Detection"  # "Attack"에서 "Detection"으로 변경
        else:
            phase = "Phase 3: Surrounding and Neutralizing"
        minutes = (frame * self.dt) / 60
        hours, mins = divmod(minutes, 60)
        self.time_text.set_text(f"Time: {int(hours)}h {int(mins)}m")

        ships_status = []
        for s in self.ships:
            # 상태별 색상
            status = s.get_status()
            ships_status.append(f"Ship{s.id}: {status} (HP:{s.health:.0f})")
        self.status_text.set_text(phase + "\n" + "\n".join(ships_status))

        # 1. 불법어선 상태 업데이트
        for ship in self.ships:
            ship.update(frame)

        # 2. 드론 탐지/상태 전이
        detected_this_frame = False
        for drone in self.drones:
            if drone.state == 'patrol':
                detected_ship = drone.detect_ships(self.ships, frame, self.detection_threshold)
                if detected_ship:
                    detected_this_frame = True

        # 탐지된 순간 모든 드론이 추격
        for ship in self.ships:
            if ship.detected and ship.alive and any(d.state == 'patrol' for d in self.drones):
                self._assign_target_to_drones(ship, frame)

        # 3. 드론 상태 전이 및 공격
        for drone in self.drones:
            # 불법어선이 기동불능이 되면 guarding 상태로 전환
            if drone.target_ship and not drone.target_ship.alive:
                drone.state = 'guarding'
            # 드론 이동 및 임무 수행
            drone.move(frame)

        # 4. 드론 탐지 반경 위치 업데이트
        for circ, drone in zip(self.detection_circles, self.drones):
            circ.center = (drone.x, drone.y)

        # 5. 탐지 패턴 라인 업데이트
        for i, (line, drone) in enumerate(zip(self.scan_lines, self.drones)):
            if drone.state == 'patrol':
                # 탐지 패턴 선 표시
                scan_length = drone.detection_range * 1.2
                end_x = drone.x + scan_length * math.cos(drone.scan_angle)
                end_y = drone.y + scan_length * math.sin(drone.scan_angle)
                line.set_data([drone.x, end_x], [drone.y, end_y])
            else:
                # 추적 또는 포위 상태에서는 드론과 타겟 연결
                if drone.target_ship:
                    line.set_data([drone.x, drone.target_ship.x], [drone.y, drone.target_ship.y])
                else:
                    line.set_data([], [])

        # 6. 패트롤 경로 업데이트
        for i, (line, drone) in enumerate(zip(self.patrol_lines, self.drones)):
            if drone.state == 'patrol' and hasattr(drone, 'patrol_path') and drone.patrol_path:
                # 패트롤 경로 표시
                x_pts = [p[0] for p in drone.patrol_path]
                y_pts = [p[1] for p in drone.patrol_path]
                # 현재 위치도 추가
                x_pts.append(drone.x)
                y_pts.append(drone.y)
                line.set_data(x_pts, y_pts)
            else:
                line.set_data([], [])

        # 7. 드론 및 선박 스캐터 플롯 업데이트
        drone_xy = np.array([[d.x, d.y] for d in self.drones])
        drone_colors = [self.colors.get(d.state, 'gray') for d in self.drones]
        self.dr_scatter.set_offsets(drone_xy)
        self.dr_scatter.set_color(drone_colors)

        ship_xy = []
        ship_colors = []
        for s in self.ships:
            # 모든 배의 상태를 표시(기동불능 포함)
            ship_xy.append([s.x, s.y])
            ship_colors.append(self.ship_status_colors[s.get_status()])
        self.sh_scatter.set_offsets(np.array(ship_xy) if ship_xy else np.empty((0,2)))
        if ship_colors:
            self.sh_scatter.set_color(ship_colors)

        return [self.dr_scatter, self.sh_scatter, self.status_text, self.time_text] + self.detection_circles + self.scan_lines + self.patrol_lines

# ==============================
# 시뮬레이션 실행
# ==============================
def run_simulation():
    # 불법어선 위치는 임의의 위치에 배치
    ships = [IllegalShip(0, -4, -4)]

    # 드론은 사분면별로 배치 (제1사분면, 제2사분면, 제3사분면, 제4사분면)
    drones = []
    for i in range(4):
        if i == 0:  # 제1사분면
            x, y = 4, 4
        elif i == 1:  # 제2사분면
            x, y = -4, 4
        elif i == 2:  # 제3사분면
            x, y = -4, -4
        else:  # 제4사분면
            x, y = 4, -4
        drones.append(Drone(i, x, y))

    # 배경 이미지 경로 설정 - 없을 경우 None으로 처리됨
    try:
        background_path = "연평도.png"
    except:
        background_path = None

    # 시뮬레이션 실행
    sim = Simulation(drones, ships, background_image_path=background_path)

    # 애니메이션 생성 및 실행
    anim = FuncAnimation(sim.fig, sim.update, frames=sim.frames,
                        init_func=sim.init, interval=40, blit=True)

    plt.close(sim.fig)  # 인라인 표시를 위해 닫음
    return HTML(anim.to_jshtml())

# 애니메이션 실행
if __name__ == "__main__":
    animation = run_simulation()
    display(animation)